---
title: "INLABru : Convenient digital soil mapping model fitting using INLA-SPDE"
author: "Nicolas Saby, Thomas Opitz"
date: "24/04/2023"
bibliography: reference.bib
editor: visual
format:
  pdf:
    documentclass: article
    papersize: a4
    toc: true
    number-sections: true
    colorlinks: true
    geometry:
      - top=30mm
      - left=20mm
      - heightrounded
    code-annotations: false
    code-block-border-left: true
---

# Introduction

Pedometricians are nowdays fans of machine learning approaches with on the top the widely used random forest algorithm, see for example [@poggio_soilgrids_2021]. These algorithms are indeed particularly adapted to the management of large data sets to map soil properties on wide extent. This trend also seems to be accompanied by a lesser use of geostatistical techniques that require more computer resource and statistical skills. However, ML Technics ignore spatial correlations in the calibration steps or predictions steps. Moreover, if prediction is performed in several steps (*eg* regression or any other machine learning prediction in step 1, followed by spatial kriging of the residuals in step 2), then an accurate assessment of the prediction uncertainties is difficult since uncertainties from the first step must be propagated through to the second step.

In this paper, we propose to solve these issues by using the fully Bayesian estimation framework based on the integrated nested Laplace approximation (INLA,[@Rue2009]), combined with the so-called stochastic partial differential equation approach [SPDE, @Lindgren2011] providing numerically convenient representations of Gaussian processes over continuous space. The INLA method is an alternative to traditional Markov chain Monte Carlo methods for Bayesian estimation and provides off-the-shelf implementation of fast and accurate deterministic approximations of posterior inferences for a large class of models. INLA with SPDE is handle to handle very large dataset.

However, the use of the INLA method was probably hindered by the complexity of the INLA R package. Recently, the INLABru R package [@yuan2017point] originally developed for the point process models has integrates a range of function for SPDE methods. We propose here to show a example.

# Softwares

We use here a set of R packages.

```{r}
library(INLA)
library(inlabru)
library(dplyr)
library(tmap)
library(gstat) # for the meuse data
library(tmap)
library(ggplot2)
```

The `INLABru` method is a wrapper for INLA::inla and provides multiple enhancements.

# Data

We use the open data meuse from `gstat` package

```{r}
data(meuse)
data(meuse.grid)

str(meuse)
str(meuse.grid)

```

Create `sp` objects for INLAbru. a spatial point dataframe corresponding to the regression matrix and the predicting grid

```{r}
coordinates(meuse) <- c('x','y')

coordinates(meuse.grid) <- c("x","y")
gridded(meuse.grid) = TRUE

```

# The model

We construct a hierarchical model in the framework of the SCORPAN approach for the soil property $z(s)$ of a spatial location $s$.

$$
z(s) = {\text{Intercept}} + \underbrace{ \sum_{i\in \text{scorpan}}\beta^{\text{sc}}_i z^{\text{sc}}_i(s)}_{\text{SCORPAN factors} } +\underbrace{W_i(s)}_{\text{Gaussian field}}
$$

# SPDE model with \`INLABru\`

\`INLA\` and \`inlabru\` use a space triangulation method to estimate spatial Gaussian effects with a Matérn covariance function. The spatial Gaussian random field is computed at the mesh nodes by resolving a Stochastic Partial Differential Equation (SPDE), while it is computed elsewhere by interpolation. The mesh definition is based on a trade-off between the finer spatial scale of the spatial effect (higher resolution) and the number of nodes (lower resolution). Below, we present how to build a mesh from the set of coordinates of the calibration sites.

First, we create a matrix \`xyMesh\` with coordinates of the sites. Next, we define the boundaries of the domain used for computing the spatial latent effect with the SPDE approach. Generally, it is better to compute an internal boundary and an external boundary with different resolutions to address boundary effects.

The \`INLA::inla.mesh.2d\` function creates a triangle mesh based on initial point locations, specified or automatic boundaries, and mesh quality parameters.

```{r}
cutoffValue = 50 # in meter

xyMesh <- rbind(coordinates(meuse)) # transform into matrix

max.edge = diff(range(xyMesh[,1]))/(3*5)
bound.outer = diff(range(range(xyMesh[,1])))/3

bndint <- inla.nonconvex.hull(meuse, convex=-.05)
bndext <- inla.nonconvex.hull(meuse, convex=-.3)

# Use of inla.mesh.2d 
mesh = inla.mesh.2d(loc=xyMesh,
                    boundary = list(int = bndint,
                                    out = bndext),
                    max.edge = c(1,3)*max.edge, 
                    cutoff = cutoffValue,
                    crs = meuse@proj4string@projargs)
ggplot() +
  gg(mesh) +
  gg(meuse) +
  coord_equal()
```

```{r , eval=FALSE}

cutoffValue = 50 # in meter

xyMesh <- rbind(coordinates(meuse))

max.edge = diff(range(xyMesh[,1]))/(3*5)
bound.outer = diff(range(range(xyMesh[,1])))/3

m11 = INLA::inla.nonconvex.hull(meuse,
                                convex = 400
                                )

# the max.edge to be between 1/5 and 1/10 of the estimated range and
# then update the offset and cutoff values accordingly).

mesh = INLA::inla.mesh.2d(boundary = m11,
                    loc=xyMesh,
                    max.edge = c(1,3)*max.edge, #
                    cutoff = cutoffValue, # minimum distance between two nodes
                    offset = c(max.edge, bound.outer),
                    min.angle=21
)

ggplot() +
  gg(mesh) +
  gg(meuse) +
  coord_equal()

```

We choose the Matérn covariance function for the Gaussian random field because it can be easily fitted in \`INLA\` using a SPDE. The Matérn covariance in \`INLA\` depends on three parameters: a fractional order parameter \*alpha\* in the SPDE linked to the smoothness of the solution, a standard deviation parameter \*sigma\*, and a spatial correlation parameter known as the \*range\*. We specify these parameters in our model by selecting a penalized complexity prior using the \`INLA::inla.spde2.pcmatern\` function. For more details, please refer to the introduction to spatial models with \`INLA\` in chapter 7 at \<https://becarioprecario.bitbucket.io/inla-gitbook/ch-spatial.html\>.

```{r}
matern <-
  INLA::inla.spde2.pcmatern(mesh,
                      alpha = 2,# fractional operator which is related
                      prior.sigma = c(1, 0.5),# P(sigma > 1) = 0.5
                      prior.range = c(10000, 0.9)  # P(range < 10000 m) = 0.9
  )

```

We then specify the model components using the convinient `INLA Bru` approach. We use as example a linear relationship with the covariate correspind to the distance to the river.

```{r}
cmp <- om ~ field(coordinates, model = matern) + 
  Intercept(1) + 
  dist(dist, model = 'linear')     
  ) 

```

We can then fit the model

the eb strategy . We can

```{r}
fit <- bru(cmp,
           meuse,
           family = "gaussian",
           options = list(
             control.inla = list(int.strategy = "eb"),
             verbose = FALSE)
)

```

blabla sur le model

then predic using simulation

```{r}
pred <- predict(
  fit,
  meuse.grid,
  ~ field + Intercept + dist + soil,
  num.threads = 2
)
```

Or draw a 5 samples from the posterior distribution

```{r}
samp <- generate(fit, 
                 meuse.grid,
                 ~ field + Intercept + dist + soil,
                 n.samples = 5
)

str(samp)

pred$sample <- samp[, 1]
```

# plotting results

## the differents effects

convienient

```{r}
plot(fit, "Intercept")
plot(fit, "dist")
plot(fit,"soil")
```

## the maps

You can plot the median, lower 95% and upper 95% density surfaces as follows (assuming that the predicted intensity is in object `pred`).

```{r}
pred$q0.025[pred$q0.025<0] = 0 
tm_shape(pred) +
  tm_raster(
    c("q0.025","median","q0.975")
    )
```

The sample from the posterior distribution

```{r}
tm_shape(pred) + tm_raster("sample")
```

## Supplementary

It is possible to

### References

::: {#refs}
:::
